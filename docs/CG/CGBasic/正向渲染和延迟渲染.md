# 正向渲染和延迟渲染

## 正向渲染

正向渲染是传统的光照方式。由顶点着色器传入顶点信息，片段着色器中传入光源信息(可能有多个光源)，逐片段的计算颜色。多光源的情况下，利用可加性，遍历累加片段在光源下的颜色。再进行后面的测试融合阶段。因此传统的正向渲染思路是，先进行着色，再进行深度测试。其的主要缺点就是光照计算跟场景复杂度和光源个数有很大关系。假设有 n 个物体，m 个光源，且每个物体受所有光源的影响，那么复杂度就是 O(m*n)。

优点：简单直接，容易理解，容易实现。 缺点：

1. 如果光源特别多的情况下(1000个)，这样的实现方式是不可行的。
2. 大部分片段会在之后的深度测试中被丢弃，造成了性能的浪费。

------

## 延迟渲染

**why**：延迟渲染为了解决多光源情况下，正向渲染复杂度过高的问题。 

**what**：在深度测试之后做颜色计算，也就是屏幕空间，保证了一个像素只会被渲染一次。渲染所需的信息来源于G-buffer，而不是顶点着色器。时间复杂度为O(m+n);

**how**：两个pass。第一个pass(Geometry Pass)输出几何信息到G-buffer中，比如position vector，color vector，normal vector，specular vector；第二个pass(Lighting Pass)渲染的是一个屏幕大小的二维矩形，在G-buffer中存储的数据对此矩阵的每一个片段计算场景的光照。

优点：减少了性能的浪费，多光源成为了可能 缺点：

1. 场景数据较大，消耗很多显存，尤其是高精度的场景数据比如position；
2. 不支持混合，不能使用MSAA。
3. 不支持透明物体的渲染。Gbuffer只是把当前能看到的像素记录下来，但是透明的，同一个像素点，可能需要记录更多！所以，延迟渲染的时候，一般都是先渲染非透明的Mesh，后续再单独渲染透明Mesh。
4. 迫使编程者对大部分场景的光照使用相同的光照算法，可以通过包含更多关于材质的数据到G缓冲中来减轻这一缺点

### G-buffer

gbuffer中存储了计算一个片段颜色所需的全部数据，用MRT(多目标渲染)，在geometry pass中把数据写入gbuffer。光照计算所需的数据有：

- 一个3D位置向量(RGB,16F)来计算(插值)片段位置变量供`lightDir`和`viewDir`使用
- 一个RGB漫反射颜色向量(每分量8位)，也就是反照率(Albedo)
- 一个3D法向量(RGB,16F)来判断平面的斜率
- 一个镜面强度(Specular Intensity)浮点值
- 所有光源的位置和颜色向量
- 玩家或者观察者的位置向量

------

## 延迟渲染与MSAA



------

## 延迟渲染和正向渲染的结合

