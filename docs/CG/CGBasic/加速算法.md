# 加速算法
why：在光线追踪算法中，我们需要判断一根光线是否与场景中的物体相交。若没有加速算法，我们只能把光线与场景中的物体逐个求交来判断是否有交点。当场景中物体数量较多或是光线数量较多的时候，计算量是非常恐怖的，因此需要一个光线与场景求交的加速算法。

what：加速算法包含了两个步骤：

1. 划分场景(划分对象 或 划分空间)；
2. 与子场景求交，若没有交点return false；若有交点，再判断是否与子场景中的物体是否有交点。

## BVH

what：是划分对象的算法。

how：

建树：BVH树的所有节点都是一个AABB包围盒，根节点的轴对齐包围盒包含了场景中的所有对象。把根节点划分为两个子包围盒，在x,y,z中随机选择一个轴，把包围盒中的对象按该轴排序，选择中间的对象为分界点，划分左右两边的对象。再对每一个子包围盒做上述操作，直到包围盒中只剩1个对象。

求交：首先计算光线与根包围盒是否有交点。若无交点，说明光线与整个场景都没有交点，return；若有交点，若有交点，那么必定只和左孩子 或者 右孩子有交点，光线和左右孩子求交，舍弃掉没有交点的那颗子树，以此类推。。。**求交次数为O(h)**

### 1.求交算法

为了方便求交，此处使用轴对齐包围盒AABB。

### 2.划分场景

1. 可以每次随机指定一个轴，把物体按该轴进行排序，从中间划分为两部分
2. 可以每次选择最长的那个轴，从中间划为两部分

### BVH树的应用

- 碰撞检测(每个三角形之间的碰撞)

在Bullet、Havok等物理引擎的碰撞粗测阶段，使用一种叫做 **动态层次AABB包围盒树(Dynamic Bounding Volume Hierarchy Based On AABB Tree)** 的结构来存储动态的AABB形状。然后通过该包围盒树的性质（不同父包围盒必定不会碰撞），快速过滤大量不可能发生碰撞的形状对。

- 射线检测/挑选几何体

射线检测从层次包围盒树自顶向下检测是否射线通过包围盒，若不通过则无需检测其子包围盒。这种剪裁可让每次射线检测平均只需检测O(logN)数量的形状。通过一个点位置快速挑选该点的几何体也是类似的原理。

- 视锥剔除

对BVH树进行中序遍历的视锥测试，如果一个节点所代表的包围盒不在视锥范围内，那么其所有子节点所代表的包围盒都不会在视锥范围内，则可以跳过测试其子节点。在这个遍历过程中，通过测试的节点所代表的几何体才可以发送渲染命令。

- 辅助BSP树构建

在BSP树的构建中，利用球体树辅助，可以将复杂度从O(Nlog²N)下降为O(NlogN)的复杂度。

## Octree

what：划分空间的算法

## BVH树和八叉树的区别

BVH实现起来比八叉树稍微麻烦一点，八叉树只需要知道场景的大小和模型的精度就能进行分割，然后将模型一个个塞进去即可，而BVH需要了解全部的模型信息才能进行下一步分割。而且游戏场景一般都分布比较均匀（一大片空地的情况少见），上图中物体集中在某一区域的情况比较少，所以利用八叉树和BVH树的层数和效率应该是差不多的。